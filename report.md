# آزمایش ۷ آزمایشگاه مهندسی نرم‌افزار

## بازآرایی کد

### استفاده از الگوی `Facade`

- `CompilerFacade` ایجاد کردم که پیچیدگی‌های مدیریت `Parser`, `ErrorHandler` و عملیات فایل را پنهان می‌کند.
- `ParserSubsystemFacade` ایجاد کردم که مقداردهی پیچیده `ParseTable`, `Rules`, `CodeGenerator` را مدیریت می‌کند.
این `facade` باعث ساده‌شدن کنستراکتور کلاس `Parser` و جداسازی منطق مقداردهی از منطق پارسینگ شده است.

### استفاده `polymorphism` به جای شرط

- سوییچ‌کیس موجود در متد `startParse` کلاس `Parser` را با ایجاد کلاس‌های `ActionHandler` بازآرایی کردم.
به ازای هر کیس در سوییچ‌کیس یک کلاس ساختم که کد داخل کیس در آن کلاس اجرا شود. همچنین یک مپ ساختم که از اکشن مورد نظر به اکشن‌هندلر مربوطه مپ شود.

### جداسازی `Query` از `Modifier`

- متد `getNextParameter` در کلاس `SymbolTable.Method` را بازآرایی کردم که هم مقدار برمی‌گرداند و هم وضعیت را تغییر می‌داد.
این متد را به دو متد جداگانه `getCurrentParameter` (فقط خواندن) و `advanceParameterIndex` (فقط تغییر وضعیت) تقسیم کردم.

### استفاده از الگوی `Self Encapsulate Field`

- فیلدهای عمومی کلاس `Address` را به خصوصی تبدیل کرده و متدهای `getter` برای دسترسی به آن‌ها اضافه کردم.
همچنین تغییرات لازم در `CodeGenerator` را نیز انجام دادم.

### استفاده از الگوی `Replace Magic Number with Symbolic Constant`

- اعداد جادویی (۰ تا ۳۳) موجود در `switch statement` متد `semanticFunction` کلاس `CodeGenerator` را با ثابت‌های معنادار جایگزین کردم.

### استفاده از الگوی `Extract Class`

- با توجه به بزرگی کلاس `CodeGenerator` این کلاس برای ریفکتور کردن بسیار مناسب است. با کمی دقت متوجه می‌شویم که این کلاس کارهای بسیاری از تولید کد
کامپایلر را برای مثال عملیات ریاضی، کنترل برنامه و... راانجام می‌دهد. با توجه به این به کمک الگوی `Extract Class` چندین
کلاس مختلف که از نظر منطقی با آن مشابه هستند مانند `ControlFlowCodeGenerator`, `ExpressionGenerator`, `SymbolDefinitionHandler`
را از آن استخراج می‌کنیم. البته بیشتر از این هم می‌توان از این کلاس، کلاس‌های دیگر استخراج کرد.

## سوالات

### سوال ۱

- **کد تمیز**: کدی که قابل خواندن، قابل درک، ساده، قابل نگهداری و پیرو از اصول طراحی نرم‌افزار است.
- **بدهی فنی**: هزینه‌ای که برای تغییرات آینده کد متحمل می‌شویم در نتیجه انتخاب راه‌حل آسان به جای بهترین طراحی.
- **بوی بد**: نشانه‌هایی در کد که دلالت بر مشکلات عمیق‌تر طراحی یا پیاده‌سازی دارند و نیاز به بازآرایی را نشان می‌دهند.

### سوال ۲

- **Bloaters (متورم‌کننده‌ها)**: کدها، متدها و کلاس‌هایی که به اندازه‌ای بزرگ شده‌اند که کار با آن‌ها دشوار است و معمولاً با گذشت زمان و تکامل برنامه تجمع می‌یابند.
- **Object-Orientation Abusers (سوءاستفاده‌کنندگان از شیءگرایی)**: بوهایی که نشان‌دهنده کاربرد ناقص یا نادرست اصول برنامه‌نویسی شیءگرا هستند.
- **Change Preventers (مانع‌های تغییر)**: بوهایی که باعث می‌شوند برای تغییر یک بخش از کد، مجبور به تغییر بخش‌های زیادی از کد باشیم و توسعه را پیچیده و پرهزینه کنند.
- **Dispensables (غیرضروری‌ها)**: چیزهای بی‌مورد و غیرضروری که حذف آن‌ها کد را تمیزتر، کارآمدتر و قابل‌فهم‌تر می‌کند.
- **Couplers (جفت‌کننده‌ها)**: بوهایی که باعث جفت‌شدگی بیش‌ازحد بین کلاس‌ها می‌شوند یا نشان‌دهنده جایگزینی جفت‌شدگی با تفویض بیش‌ازحد هستند.

### سوال ۳

- **دسته‌بندی**: `Feature Envy` در دسته `Couplers` (جفت‌کننده‌ها) قرار می‌گیرد.
- **بازآرایی‌های پیشنهادی**: برای برطرف کردن این بو از `Move Method` (انتقال متد) یا `Extract Method` (استخراج متد) استفاده می‌شود تا متد به کلاسی که بیشتر با داده‌هایش کار می‌کند منتقل شود.
- **موارد نادیده‌گیری**: زمانی که متد برای حفظ اصول طراحی یا `encapsulation` باید در کلاس فعلی باقی بماند، یا زمانی که انتقال متد باعث ایجاد مشکلات بیشتری می‌شود.

### سوال ۴

- **عملکرد برنامه**: `Bug` باعث اشتباه در عملکرد برنامه یا خرابی آن می‌شود، در حالی که `Code Smell` عملکرد برنامه را تحت تأثیر قرار نمی‌دهد و برنامه به درستی کار می‌کند.
- **هدف و تأثیر**: `Bug` مشکل فوری و قابل مشاهده در رفتار برنامه است که باید سریعاً برطرف شود، اما `Code Smell` نشان‌دهنده مشکلات طراحی و کیفیت کد است که بر نگهداری و توسعه آینده تأثیر می‌گذارد.

### سوال ۵

#### ۱. **Large Class**

- **مکان**: `Phase1CodeGenerator.java` (۳۴۷ خط)، `ClassStructure.java` (۳۲۴ خط)، `ClassMethod.java` (۲۰۴ خط)
- **توضیح**: این کلاس‌ها خیلی بزرگ شده‌اند و مسئولیت‌های متعددی دارند که باعث سختی نگهداری و درک آن‌ها می‌شود.

#### ۲. **Long Method**

- **مکان**: `Main.java` - متد `main()` (حدود ۵۰ خط)، `loopOnGUI()` (حدود ۴۰ خط)
- **توضیح**: این متدها خیلی طولانی هستند و کارهای مختلف در یک متد انجام می‌دهند.

#### ۳. **Switch Statements**

- **مکان**: `Main.java` در متد `main()` خطوط ۷۵-۹۳
- **توضیح**: استفاده از switch-case برای پردازش آرگومان‌ها به جای استفاده از polymorphism یا pattern‌های مناسب.

#### ۴. **Primitive Obsession**

- **مکان**: استفاده مکرر از `String` برای نام کلاس‌ها و انواع مختلف در سراسر کدبیس
- **توضیح**: به جای استفاده از کلاس‌های مناسب، از انواع primitive مثل String استفاده شده است.

#### ۵. **Data Class**

- **مکان**: `CompleteValueType.java`، `BasicDiagramStatus.java`
- **توضیح**: این کلاس‌ها فقط داده نگهداری می‌کنند و رفتار خاصی ندارند.

#### ۶. **Feature Envy**

- **مکان**: `Phase1CodeGenerator` که بیش از حد به جزئیات کلاس‌های `CompleteClass` و `CompleteMethod` دسترسی دارد
- **توضیح**: این کلاس بیش از حد به ویژگی‌های کلاس‌های دیگر وابسته است.

#### ۷. **Long Parameter List**

- **مکان**: کنستراکتور `Phase2CodeGenerator` که ۴ پارامتر String می‌گیرد
- **توضیح**: تعداد زیاد پارامتر باعث پیچیدگی و سختی استفاده می‌شود.

#### ۸. **Duplicate Code**

- **مکان**: تکرار کدهای مشابه برای ایجاد فایل‌ها در `Phase1CodeGenerator.java` خطوط ۲۸-۵۶
- **توضیح**: کدهای مشابه برای نوشتن فایل‌های مختلف تکرار شده است.

#### ۹. **Message Chains**

- **مکان**: `Main.java` در متدهای مختلف مثل `guiDiagram.getResultOfGraphOperation().getDependencyNumber()`
- **توضیح**: زنجیره‌ای از فراخوانی متدها که باعث coupling بالا می‌شود.

#### ۱۰. **Comments**

- **مکان**: `Phase1CodeGenerator.java` خط ۱۱: `///TODO delete this and move all functions into Complete* classes`
- **توضیح**: کامنت‌های TODO که نشان‌دهنده کدهای ناتمام یا نیاز به بازآرایی هستند و به جای بهبود کد، فقط کامنت گذاشته شده است.

### سوال ۶

- **عملکرد**: پلاگین `formatter` به‌طور خودکار کد را بر اساس قوانین و استانداردهای مشخص قالب‌بندی می‌کند و سبک یکنواخت کدنویسی را در سراسر پروژه تضمین می‌کند.
- **مزایا**: خوانایی کد را بهبود می‌بخشد، زمان صرف‌شده برای قالب‌بندی دستی را کاهش می‌دهد، و تعارضات مربوط به سبک کدنویسی در تیم‌های توسعه را از بین می‌برد.
- **رابطه با بازآرایی**: `formatter` بخشی از فرآیند نگهداری کد تمیز محسوب می‌شود و قبل یا بعد از بازآرایی کمک می‌کند کد منظم و قابل‌خواندن باقی بماند و فرآیند بازآرایی را تسهیل می‌کند.
